---
# Service and Security Discovery
# Scans for services relevant to the collection's roles

- name: Store service discovery results
  ansible.builtin.set_fact:
    discovered_services:
      # All running services for reference
      running: >-
        {{ ansible_facts.services | dict2items |
           selectattr('value.state', 'defined') |
           selectattr('value.state', 'equalto', 'running') |
           map(attribute='key') |
           map('regex_replace', '\\.service$', '') | list }}
      # All enabled services for reference
      enabled: >-
        {{ ansible_facts.services | dict2items |
           selectattr('value.status', 'defined') |
           selectattr('value.status', 'equalto', 'enabled') |
           map(attribute='key') |
           map('regex_replace', '\\.service$', '') | list }}

      # Services that collection roles specifically manage
      collection_relevant:
        # Security services (system_security role)
        ssh_enabled: >-
          {{ ('ssh' in ansible_facts.services and
              ansible_facts.services['ssh'].get('status', '') == 'enabled') or
             ('sshd' in ansible_facts.services and
              ansible_facts.services['sshd'].get('status', '') == 'enabled') or
             ('ssh.service' in ansible_facts.services and
              ansible_facts.services['ssh.service'].get('status', '') == 'enabled') or
             ('sshd.service' in ansible_facts.services and
              ansible_facts.services['sshd.service'].get('status', '') == 'enabled') }}
        fail2ban_enabled: >-
          {{ ('fail2ban' in ansible_facts.services and
              ansible_facts.services['fail2ban'].get('status', '') == 'enabled') or
             ('fail2ban.service' in ansible_facts.services and
              ansible_facts.services['fail2ban.service'].get('status', '') == 'enabled') }}
        firewall_detected: >-
          {{ ('ufw' in ansible_facts.services and
              ansible_facts.services['ufw'].get('status', '') == 'enabled') or
             ('ufw.service' in ansible_facts.services and
              ansible_facts.services['ufw.service'].get('status', '') == 'enabled') or
             ('firewalld' in ansible_facts.services and
              ansible_facts.services['firewalld'].get('status', '') == 'enabled') or
             ('firewalld.service' in ansible_facts.services and
              ansible_facts.services['firewalld.service'].get('status', '') == 'enabled') or
             ('iptables' in ansible_facts.services and
              ansible_facts.services['iptables'].get('status', '') == 'enabled') or
             ('iptables.service' in ansible_facts.services and
              ansible_facts.services['iptables.service'].get('status', '') == 'enabled') }}
        firewall_type: >-
          {%- if ('ufw' in ansible_facts.services and ansible_facts.services['ufw'].get('status', '') == 'enabled') or
                 ('ufw.service' in ansible_facts.services and ansible_facts.services['ufw.service'].get('status', '') == 'enabled') -%}
            ufw
          {%- elif ('firewalld' in ansible_facts.services and ansible_facts.services['firewalld'].get('status', '') == 'enabled') or
                   ('firewalld.service' in ansible_facts.services and ansible_facts.services['firewalld.service'].get('status', '') == 'enabled') -%}
            firewalld
          {%- elif ('iptables' in ansible_facts.services and ansible_facts.services['iptables'].get('status', '') == 'enabled') or
                   ('iptables.service' in ansible_facts.services and ansible_facts.services['iptables.service'].get('status', '') == 'enabled') -%}
            iptables
          {%- else -%}
            none
          {%- endif %}
        firewall_type_output: >-
          {%- if ('ufw' in ansible_facts.services and ansible_facts.services['ufw'].get('status', '') == 'enabled') or
                 ('ufw.service' in ansible_facts.services and ansible_facts.services['ufw.service'].get('status', '') == 'enabled') -%}
            ufw
          {%- elif ('firewalld' in ansible_facts.services and ansible_facts.services['firewalld'].get('status', '') == 'enabled') or
                   ('firewalld.service' in ansible_facts.services and ansible_facts.services['firewalld.service'].get('status', '') == 'enabled') -%}
            firewalld
          {%- elif ('iptables' in ansible_facts.services and ansible_facts.services['iptables'].get('status', '') == 'enabled') or
                   ('iptables.service' in ansible_facts.services and ansible_facts.services['iptables.service'].get('status', '') == 'enabled') -%}
            ufw
          {%- else -%}
            none
          {%- endif %}

        # Container platform services
        docker_enabled: >-
          {{ ('docker' in ansible_facts.services and
              ansible_facts.services['docker'].get('status', '') == 'enabled') or
             ('docker.service' in ansible_facts.services and
              ansible_facts.services['docker.service'].get('status', '') == 'enabled') }}

        # Common server services (referenced in examples)
        cron_enabled: >-
          {{ ('cron' in ansible_facts.services and
              ansible_facts.services['cron'].get('status', '') == 'enabled') or
             ('crond' in ansible_facts.services and
              ansible_facts.services['crond'].get('status', '') == 'enabled') or
             ('cron.service' in ansible_facts.services and
              ansible_facts.services['cron.service'].get('status', '') == 'enabled') or
             ('crond.service' in ansible_facts.services and
              ansible_facts.services['crond.service'].get('status', '') == 'enabled') }}

        # Workstation services (referenced in examples)
        networkmanager_enabled: >-
          {{ ('NetworkManager' in ansible_facts.services and
              ansible_facts.services['NetworkManager'].get('status', '') == 'enabled') or
             ('NetworkManager.service' in ansible_facts.services and
              ansible_facts.services['NetworkManager.service'].get('status', '') == 'enabled') }}
        bluetooth_enabled: >-
          {{ ('bluetooth' in ansible_facts.services and
              ansible_facts.services['bluetooth'].get('status', '') == 'enabled') or
             ('bluetooth.service' in ansible_facts.services and
              ansible_facts.services['bluetooth.service'].get('status', '') == 'enabled') }}

- name: Get firewall configuration using proper modules
  block:
    - name: Check if UFW binary exists
      ansible.builtin.stat:
        path: /usr/sbin/ufw
      register: ufw_binary_exists
      when: discovered_services.collection_relevant.firewall_type == 'ufw'

    - name: Get UFW status output for parsing
      ansible.builtin.command: ufw status
      register: ufw_status_output
      become: true
      changed_when: false
      when:
        - discovered_services.collection_relevant.firewall_type == 'ufw'
        - ufw_binary_exists.stat.exists
      # Let this fail if UFW is installed but broken

    - name: Parse UFW rules into structured format
      ansible.builtin.set_fact:
        firewall_rules: []
        firewall_type_detected: "ufw"
      when:
        - discovered_services.collection_relevant.firewall_type == 'ufw'
        - ufw_status_output.stdout_lines is defined

    - name: Build UFW rules list
      ansible.builtin.set_fact:
        firewall_rules: "{{ firewall_rules + [simple_rule] }}"
      vars:
        line_parts: "{{ item.split() }}"
        port_proto: "{{ line_parts[0] }}"
        # Extract comment if it exists (UFW comments appear after #)
        rule_comment: "{{ item.split('#')[1].strip() if '#' in item else '' }}"
        simple_rule:
          rule: "allow"
          port: "{{ port_proto.split('/')[0] if '/' in port_proto else port_proto }}"
          proto: "{{ port_proto.split('/')[1] if '/' in port_proto else 'any' }}"
          comment: "{{ rule_comment }}"
      loop: "{{ ufw_status_output.stdout_lines }}"
      when:
        - discovered_services.collection_relevant.firewall_type == 'ufw'
        - ufw_status_output.stdout_lines is defined
        - line_parts | length >= 3
        - line_parts[1] == 'ALLOW'
        - "'Status:' not in item"
        - "'To' not in item"
        - "not item.startswith('[')"

    - name: Get firewalld info
      ansible.posix.firewalld_info:
        active_zones: true
        zones: true
        services: true
        ports: true
      register: firewalld_info
      become: true
      when: discovered_services.collection_relevant.firewall_type == 'firewalld'
      # Let this fail if firewalld is enabled but broken

    - name: Parse firewalld rules into structured format
      ansible.builtin.set_fact:
        firewall_rules: []
        firewall_type_detected: "firewalld"
      when:
        - discovered_services.collection_relevant.firewall_type == 'firewalld'
        - firewalld_info.zones is defined

    - name: Build firewalld rules list from all zones
      ansible.builtin.set_fact:
        firewall_rules: "{{ firewall_rules + firewalld_parsed_rules }}"
      vars:
        firewalld_parsed_rules: >-
          {%- set rules = [] -%}
          {%- for zone_name, zone_data in firewalld_info.zones.items() -%}
            {# Add port rules #}
            {%- for port_spec in zone_data.ports | default([]) -%}
              {%- set port_parts = port_spec.split('/') -%}
              {%- set _ = rules.append({
                'rule': 'allow',
                'port': port_parts[0],
                'proto': port_parts[1] if port_parts | length > 1 else 'any'
              }) -%}
            {%- endfor -%}
            {# Add service rules #}
            {%- for service_name in zone_data.services | default([]) -%}
              {%- set _ = rules.append({
                'rule': 'allow',
                'port': service_name,
                'proto': 'any'
              }) -%}
            {%- endfor -%}
          {%- endfor -%}
          {{ rules }}
      when:
        - discovered_services.collection_relevant.firewall_type == 'firewalld'
        - firewalld_info.zones is defined

    - name: Get iptables rules (simple)
      ansible.builtin.shell: |
        iptables -L INPUT -n | grep "ACCEPT.*dpt:" | grep -o "dpt:[0-9]*" | cut -d: -f2
      register: iptables_ports_simple
      become: true
      changed_when: false
      failed_when: iptables_ports_simple.rc not in [0, 1, 127]  # Allow grep no matches and command not found
      when: discovered_services.collection_relevant.firewall_type == 'iptables'

    - name: Parse iptables rules into structured format
      ansible.builtin.set_fact:
        firewall_rules: []
        firewall_type_detected: "iptables"
      when:
        - discovered_services.collection_relevant.firewall_type == 'iptables'
        - iptables_ports_simple.stdout_lines is defined

    - name: Build iptables rules list
      ansible.builtin.set_fact:
        firewall_rules: "{{ firewall_rules + [firewall_rule] }}"
      vars:
        firewall_rule:
          rule: "allow"
          port: "{{ item }}"
          proto: "tcp"
      loop: "{{ iptables_ports_simple.stdout_lines | default([]) }}"
      when:
        - discovered_services.collection_relevant.firewall_type == 'iptables'
        - iptables_ports_simple.stdout_lines is defined

  when: discovered_services.collection_relevant.firewall_detected | default(false)

- name: Set empty firewall rules when no firewall detected
  ansible.builtin.set_fact:
    firewall_rules: []
    firewall_type_detected: "none"
  when: not (discovered_services.collection_relevant.firewall_detected | default(false))

- name: Set firewall variables (manage_firewall role format)
  ansible.builtin.set_fact:
    firewall_enable: "{{ discovered_services.collection_relevant.firewall_detected }}"
    firewall_enable_fail2ban: "{{ discovered_services.collection_relevant.fail2ban_enabled }}"
    firewall_custom_rules: "{{ firewall_rules | default([]) }}"
  tags:
    - services
    - security
    - discovery
