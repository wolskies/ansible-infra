---
# Simplified APT Package and Repository Discovery (Debian/Ubuntu)

- name: Discover APT packages and repositories
  block:
    # Step 1: Get manually installed packages with debug info
    - name: Get all manually installed packages
      ansible.builtin.command: apt-mark showmanual
      register: all_manual_packages_result
      become: true
      changed_when: false
      failed_when: false

    - name: Get base system packages (required/important priority)
      ansible.builtin.shell: |
        # Use apt-cache policy instead of apt list for more reliable priority detection
        dpkg-query -W -f='${Package} ${Priority}\n' | grep -E ' (required|important)$' | cut -d' ' -f1
      register: base_packages_result
      become: true
      changed_when: false
      failed_when: false

    - name: Filter out base system packages
      ansible.builtin.set_fact:
        manual_packages: >-
          {{
            all_manual_packages_result.stdout_lines | default([])
            | difference(base_packages_result.stdout_lines | default([]))
            | reject('match', '^(base-files|base-passwd|debian-archive-keyring|ubuntu-keyring)$')
            | reject('match', '^(grub-common|initramfs-tools|systemd-sysv)$')
            | reject('match', '^lib(c6|gcc-s1|systemd0)$')
            | list
          }}


    # Step 2: Find and read third-party repository files
    - name: Find third-party repository files
      ansible.builtin.find:
        paths: ["/etc/apt/sources.list.d"]
        patterns: "*.list,*.sources"
      register: repo_files
      become: true

    - name: Read third-party repository files
      ansible.builtin.slurp:
        src: "{{ item.path }}"
      register: repo_contents
      loop: "{{ repo_files.files }}"
      become: true
      failed_when: false

    # Step 3: Parse repositories and extract key paths
    - name: Parse third-party repositories
      ansible.builtin.set_fact:
        parsed_repos: >-
          {%- set repos = [] -%}
          {%- set key_paths = [] -%}
          {%- for file in repo_contents.results | default([]) -%}
            {%- if file.content is defined -%}
              {%- set content = file.content | b64decode -%}
              {%- set filename = file.item.path | basename | regex_replace('\.(list|sources)$', '') -%}
              {%- for line in content.split('\n') -%}
                {%- if line.strip() and not line.strip().startswith('#') and line.startswith('deb') -%}
                  {%- if not ('ubuntu.com' in line or 'debian.org' in line or 'archive.ubuntu.com' in line or 'security' in line) -%}
                    {%- set repo_data = {
                        'name': filename,
                        'source_file': filename + '.list',
                        'repository': line.strip()
                    } -%}
                    {%- set _ = repos.append(repo_data) -%}
                    {%- set signed_by_match = line | regex_findall('signed-by=([^\\s\\]]+)') -%}
                    {%- if signed_by_match and signed_by_match[0] not in key_paths -%}
                      {%- set _ = key_paths.append(signed_by_match[0]) -%}
                    {%- endif -%}
                  {%- endif -%}
                {%- endif -%}
              {%- endfor -%}
            {%- endif -%}
          {%- endfor -%}
          {{ {'repos': repos, 'key_paths': key_paths} }}

    # Step 4: Check which GPG keys actually exist
    - name: Check GPG key files exist
      ansible.builtin.stat:
        path: "{{ item }}"
      register: key_file_stats
      loop: "{{ parsed_repos.key_paths }}"
      become: true
      when: parsed_repos.key_paths | length > 0

    - name: Build list of existing keys
      ansible.builtin.set_fact:
        existing_keys: >-
          {{
            key_file_stats.results | default([])
            | selectattr('stat.exists', 'equalto', true)
            | map(attribute='item')
            | list
          }}

    - name: Copy GPG key files to discovery output directory
      ansible.builtin.fetch:
        src: "{{ item }}"
        dest: "{{ discovery_paths.host_vars_dir }}/"
        flat: true
      loop: "{{ existing_keys }}"
      become: true
      when: existing_keys | length > 0

    # Step 5: Store final results in expected format
    - name: Store APT discovery results
      ansible.builtin.set_fact:
        discovered_repositories:
          apt:
            third_party_repos: "{{ parsed_repos.repos }}"
            manual_packages: "{{ manual_packages }}"
            gpg_keys: "{{ existing_keys | default([]) }}"

    - name: Debug key extraction
      ansible.builtin.debug:
        msg:
          - "Raw key paths extracted: {{ parsed_repos.key_paths }}"
          - "Key file check results: {{ key_file_stats.results | default([]) | map(attribute='item') | list }}"
          - "Keys that exist: {{ existing_keys | default([]) }}"
          - "Final discovered_repositories.apt.gpg_keys: {{ discovered_repositories.apt.gpg_keys | default('UNDEFINED') }}"
      when: discovery_debug | default(false)

    - name: Debug APT discovery results
      ansible.builtin.debug:
        msg:
          - "Found {{ manual_packages | length }} manually installed packages"
          - "Found {{ parsed_repos.repos | length }} third-party repositories"
          - "Found {{ existing_keys | default([]) | length }} GPG keys"
      when: discovery_debug | default(false)

  rescue:
    - name: Handle APT discovery errors
      ansible.builtin.debug:
        msg: "APT discovery failed, setting empty results"

    - name: Set empty APT results on failure
      ansible.builtin.set_fact:
        discovered_repositories:
          apt:
            third_party_repos: []
            manual_packages: []
            gpg_keys: []
