---
# Smart package filtering using native package manager knowledge

- name: Get package facts
  ansible.builtin.package_facts:
    manager: auto

# Use the package manager's own knowledge of base system packages
- name: Get user-installed packages (Arch Linux)
  ansible.builtin.shell: |
    comm -23 <(pacman -Qqe | sort) <(pacman -Qqg base | sort)
  register: arch_user_packages
  become: true
  when: ansible_distribution == "Archlinux"
  changed_when: false

- name: Get user-installed packages (Ubuntu/Debian)
  ansible.builtin.shell: |
    apt-mark showmanual | sort
  register: ubuntu_user_packages
  become: true
  when: ansible_distribution in ["Ubuntu", "Debian"]
  changed_when: false

- name: Set user-installed packages list
  ansible.builtin.set_fact:
    user_explicit_packages: "{{ arch_user_packages.stdout_lines if ansible_distribution == 'Archlinux' else ubuntu_user_packages.stdout_lines | default([]) }}"
  when: ansible_distribution in ["Archlinux", "Ubuntu", "Debian"]

# Filter out additional system categories we don't want to manage
- name: Filter user-installed packages
  ansible.builtin.set_fact:
    "host_packages_install_{{ ansible_distribution }}": "{{ filtered_user_packages }}"
  vars:
    # Additional patterns to filter out even from user-installed packages
    system_categories:
      # Common system packages across distros
      - '^base$'           # base group itself
      - '^base-devel$'     # development tools group  
      - '^linux$'          # kernel (managed separately)
      - '^linux-firmware$' # firmware (managed separately)  
      - '^linux-headers$'  # kernel headers (managed separately)
      - '^nvidia-'         # NVIDIA drivers (hardware specific)
      - '^amd-'            # AMD drivers (hardware specific)
      - '^cuda'            # CUDA (hardware specific)
      
      # Desktop environment meta-packages (user can add individual components)
      - '^plasma-meta$'    # KDE meta package
      - '^plasma-workspace$' # KDE workspace
      - '^ubuntu-desktop'  # Ubuntu desktop meta-package
      - '^ubuntu-minimal'  # Ubuntu minimal meta-package
      
      # Audio system (managed by dedicated roles)
      - '^pipewire$'       # audio system
      - '^pipewire-'       # audio system components
      - '^wireplumber$'    # audio session manager
      - '^pulseaudio$'     # audio system
      
      # Package manager tools (system level)
      - '^apt$'            # package manager itself
      - '^dpkg$'           # package system
      - '^snapd$'          # snap package system
    filtered_user_packages: >-
      {{
        user_explicit_packages |
        reject('regex', system_categories | join('|')) |
        list
      }}
  when: ansible_distribution in ["Archlinux", "Ubuntu", "Debian"]

# Fallback for non-Arch systems - use the old pattern-based filtering but simplified
- name: Filter packages for other distributions
  ansible.builtin.set_fact:
    "host_packages_install_{{ ansible_distribution }}": "{{ filtered_packages }}"
  vars:
    # Simplified patterns for other distros
    system_package_patterns:
      - '^lib'          # Most libraries
      - '^systemd'      # systemd components  
      - '^kernel'       # kernel packages
      - '^linux-'       # linux kernel packages
      - '^glibc'        # core system libs
      - '^gcc'          # compiler internals
      - '^apt'          # package manager
      - '^dpkg'         # package system
      - '^bash$'        # system shell
      - '^dash$'        # system shell
      - '^python3$'     # base python
      - '^python3\.'    # python versions
      - '-dev$'         # development packages
      - '-dbg$'         # debug packages
      - '-doc$'         # documentation
    filtered_packages: >-
      {{
        ansible_facts.packages.keys() |
        reject('regex', system_package_patterns | join('|')) |
        list | sort
      }}
  when: ansible_distribution != "Archlinux"