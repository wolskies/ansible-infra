---
# Discover what tools the dotfiles actually reference
- name: Scan dotfiles for tool references
  ansible.builtin.shell: |
    set -e
    tools_found=()
    
    # Look for common tool references in dotfiles
    {% for tool in dotfiles_common_tools %}
    {% for command in tool.commands %}
    if grep -r "{{ command }}" "{{ dotfiles_directory }}" --include=".*" --exclude-dir=".git" >/dev/null 2>&1; then
      tools_found+=("{{ tool.name }}")
      break
    fi
    {% endfor %}
    {% endfor %}
    
    # Remove duplicates and output
    printf '%s\n' "${tools_found[@]}" | sort -u
  register: dotfiles_scan_result
  changed_when: false
  failed_when: false

- name: Check which tools are already available
  ansible.builtin.shell: |
    available_tools=()
    {% for tool in dotfiles_common_tools %}
    {% for command in tool.commands %}
    if command -v "{{ command }}" >/dev/null 2>&1; then
      available_tools+=("{{ tool.name }}")
      break
    fi
    {% endfor %}
    {% endfor %}
    
    printf '%s\n' "${available_tools[@]}" | sort -u
  register: available_tools_result
  changed_when: false

- name: Determine tools that need installation
  ansible.builtin.set_fact:
    dotfiles_referenced_tools: "{{ dotfiles_scan_result.stdout_lines | default([]) }}"
    dotfiles_available_tools: "{{ available_tools_result.stdout_lines | default([]) }}"
    dotfiles_needed_tools: "{{ dotfiles_scan_result.stdout_lines | default([]) | difference(available_tools_result.stdout_lines | default([])) }}"

- name: Display dependency discovery results
  ansible.builtin.debug:
    msg:
      - "Tools referenced in dotfiles: {{ dotfiles_referenced_tools | join(', ') if dotfiles_referenced_tools else 'none detected' }}"
      - "Tools already available: {{ dotfiles_available_tools | join(', ') if dotfiles_available_tools else 'none' }}"
      - "Tools needed: {{ dotfiles_needed_tools | join(', ') if dotfiles_needed_tools else 'none' }}"
  when: dotfiles_referenced_tools | length > 0